import logging
import os
import re
import subprocess
import tempfile

from dataclasses import dataclass
from pathlib import Path

from drakrun.config import ETC_DIR, LIB_DIR, VM_CONFIG_DIR, VOLUME_DIR, InstallInfo
from drakrun.util import safe_delete, try_run

from .storage import StorageBackendBase, get_storage_backend

log = logging.getLogger("drakrun")

FIRST_CDROM_DRIVE = "hdc"
SECOND_CDROM_DRIVE = "hdd"


def generate_vm_conf(install_info: InstallInfo, vm_id: int):
    with open(os.path.join(ETC_DIR, "../scripts", "cfg.template"), "r") as f:
        template = f.read()

    storage_backend = get_storage_backend(install_info)

    disks = []
    disks.append(storage_backend.get_vm_disk_path(vm_id))

    install_iso_path = os.path.abspath(install_info.iso_path)
    disks.append(f"file:{install_iso_path},{FIRST_CDROM_DRIVE}:cdrom,r")

    if install_info.enable_unattended:
        unattended_iso_path = os.path.join(LIB_DIR, "volumes", "unattended.iso")
        disks.append(f"file:{unattended_iso_path},{SECOND_CDROM_DRIVE}:cdrom,r")

    disks = ", ".join(['"{}"'.format(disk) for disk in disks])

    template = template.replace("{{ VM_ID }}", str(vm_id))
    template = template.replace("{{ DISKS }}", disks)
    template = template.replace("{{ VNC_PORT }}", str(6400 + vm_id))
    template = template.replace("{{ VCPUS }}", str(install_info.vcpus))
    template = template.replace("{{ MEMORY }}", str(install_info.memory))

    if vm_id == 0:
        template = re.sub("on_reboot[ ]*=(.*)", 'on_reboot = "restart"', template)

    with open(os.path.join(ETC_DIR, "configs", f"vm-{vm_id}.cfg"), "w") as f:
        f.write("# Autogenerated, don't edit this file directly!\n")
        f.write("# Instead please edit /etc/drakrun/scripts/cfg.template\n")
        f.write("# and restart drakrun@<vm_id> service.\n\n")
        f.write(template)

    log.info("Generated VM configuration for vm-{vm_id}".format(vm_id=vm_id))


def get_all_vm_conf() -> list:
    regex = re.compile(r"vm-(\d+)\.cfg")
    vm_ids = []

    for f in os.listdir(VM_CONFIG_DIR):
        reg = regex.search(f)

        if reg is not None:
            vm_ids.append(int(reg.group(1)))

    return vm_ids


def delete_vm_conf(vm_id: int) -> bool:
    return safe_delete(os.path.join(VM_CONFIG_DIR, f"vm-{vm_id}.cfg"))


class VirtualMachine:
    def __init__(
        self, backend: StorageBackendBase, vm_id: int, fmt: str = "vm-{}", cfg_path=None
    ) -> None:
        self.backend = backend
        self.vm_id = vm_id
        self._format = fmt
        self._cfg_path = cfg_path or Path(VM_CONFIG_DIR) / f"{self.vm_name}.cfg"

    @property
    def vm_name(self) -> str:
        return self._format.format(self.vm_id)

    @property
    def is_running(self) -> bool:
        res = subprocess.run(
            ["xl", "list", self.vm_name],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
        )
        return res.returncode == 0

    def create(self, pause=False, **kwargs):
        args = ["xl", "create"]
        if pause:
            args += ["-p"]
        args += [self._cfg_path]
        logging.info(f"Creating VM {self.vm_name}")
        try_run(args, f"Failed to launch VM {self.vm_name}", **kwargs)

    def pause(self, **kwargs):
        logging.info(f"Pausing VM {self.vm_name}")
        try_run(
            ["xl", "pause", self.vm_name],
            f"Failed to pause VM {self.vm_name}",
            **kwargs,
        )

    def unpause(self, **kwargs):
        logging.info(f"Unpausing VM {self.vm_name}")
        try_run(
            ["xl", "unpause", self.vm_name],
            f"Failed to unpause VM {self.vm_name}",
            **kwargs,
        )

    def save(self, filename, pause=False, cont=False, **kwargs):
        logging.info(f"Saving VM {self.vm_name}")
        args = ["xl", "save"]

        # no such args will shutdown the VM after saving
        if pause is True:
            args += ["-p"]
        elif cont is True:
            args += ["-c"]

        if kwargs.get("stderr") is None:
            kwargs["stderr"] = subprocess.STDOUT

        # we are explicitely passing stdout=None so that things can be print to terminal
        kwargs["stdout"] = kwargs.get("stdout")

        args += [self.vm_name, filename]

        try_run(args, f"Failed to save VM {self.vm_name}", **kwargs)

    def restore(self, snapshot_path=None, pause=False, **kwargs) -> None:
        """Restore virtual machine from snapshot.
        :raises: subprocess.CalledProcessError
        """
        if self.is_running:
            self.destroy()

        args = ["xl", "restore"]

        if snapshot_path is None:
            snapshot_path = Path(VOLUME_DIR) / "snapshot.sav"

        if pause is True:
            args += ["-p"]

        if kwargs.get("stderr") is None:
            kwargs["stderr"] = subprocess.STDOUT

        # we are explicitely passing stdout=None so that things can be print to terminal
        kwargs["stdout"] = kwargs.get("stdout")

        # No need to rollback vm-0. Since the state of vm-0
        # is correct by definition.
        if self.vm_id != 0 and self.backend is not None and self.vm_id is not None:
            self.backend.rollback_vm_storage(self.vm_id)

        args += [self._cfg_path, snapshot_path]
        logging.info(f"Restoring VM {self.vm_name}")
        try_run(args, msg=f"Failed to restore VM {self.vm_name}", **kwargs)

    def destroy(self, **kwargs):
        """Destroy a running virtual machine.
        :raises: subprocess.CalledProcessError
        """
        if self.is_running:
            logging.info(f"Destroying {self.vm_name}")
            try_run(
                ["xl", "destroy", self.vm_name],
                f"Failed to destroy VM {self.vm_name}",
                **kwargs,
            )

    def memory_dump(self, compressed_filepath):
        """Dump raw memory from running vm using vmi-dump-memory and compress it with gzip
        :raises: subprocess.CalledProcessError
        """

        with tempfile.NamedTemporaryFile() as raw_memdump, open(
            compressed_filepath, "wb"
        ) as compressed_file:

            log.info(f"Dumping raw memory from {self.vm_name} guest...")
            try:
                subprocess.run(
                    ["vmi-dump-memory", self.vm_name, raw_memdump.name], check=True
                )
            except subprocess.CalledProcessError as e:
                log.error(f"Dumping raw memory from {self.vm_name} failed.")
                raise e

            log.info(f"Compressing {self.vm_name} guest memory dump...")
            try:
                subprocess.run(
                    ["gzip", "-c", raw_memdump.name], check=True, stdout=compressed_file
                )
            except subprocess.CalledProcessError as e:
                log.error(f"Compressing raw memory from {self.vm_name} failed.")
                raise e


def get_domid_from_instance_id(instance_id: int) -> int:
    output = subprocess.check_output(["xl", "domid", f"vm-{instance_id}"])
    return int(output.decode("utf-8").strip())


def get_xl_info():
    xl_info_out = subprocess.check_output(["xl", "info"]).decode("utf-8", "replace")
    xl_info_lines = xl_info_out.strip().split("\n")

    cfg = {}

    for line in xl_info_lines:
        k, v = line.split(":", 1)
        k, v = k.strip(), v.strip()
        cfg[k] = v

    return cfg


def get_xen_commandline(parsed_xl_info):
    opts = parsed_xl_info["xen_commandline"].split(" ")

    cfg = {}

    for opt in opts:
        if not opt.strip():
            continue

        if "=" not in opt:
            cfg[opt] = "1"
        else:
            k, v = opt.split("=", 1)
            cfg[k] = v

    return cfg

def validate_xen_commandline():
    required_cmdline = {
        "sched": "credit",
        "force-ept": "1",
        "ept": "ad=0",
        "hap_1gb": "0",
        "hap_2mb": "0",
        "altp2m": "1",
        "hpet": "legacy-replacement",
    }

    parsed_xl_info = get_xl_info()
    xen_cmdline = get_xen_commandline(parsed_xl_info)

    unrecommended = []

    for k, v in required_cmdline.items():
        actual_v = xen_cmdline.get(k)

        if actual_v != v:
            unrecommended.append((k, v, actual_v))

    return unrecommended

@dataclass
class VmiGuidInfo:
    version: str
    guid: str
    filename: str


def vmi_win_guid(vm_name: str) -> VmiGuidInfo:
    result = subprocess.run(
        ["vmi-win-guid", "name", vm_name],
        timeout=30,
        capture_output=True,
    )

    output = result.stdout.decode()

    version = re.search(r"Version: (.*)", output)
    pdb_guid = re.search(r"PDB GUID: ([0-9a-f]+)", output)
    kernel_filename = re.search(r"Kernel filename: ([a-z]+\.[a-z]+)", output)

    if version is None or pdb_guid is None or kernel_filename is None:
        raise RuntimeError("Invalid vmi-win-guid output")

    return VmiGuidInfo(version.group(1), pdb_guid.group(1), kernel_filename.group(1))